// Цифровая сегментация изображения (удаление фона)
#include "core.hpp"
#include "imgproc.hpp"
#include "highgui.hpp"
#include "iostream"

using namespace cv; // Мы говорим интерпретатору MinGW загрузить библиотеку OpenCV
using namespace std;

const int GREEN_MIN = 20;
const int GREEN_MAX = 110;

int main()
{
    // Открываем локальный файл
    Mat src = imread("paper.jpg"); // Открываем и читаем файл с диска
    namedWindow("Original image", cv :: WindowFlags :: WINDOW_AUTOSIZE);
    imshow("Original image", src); // Отображение файла встроенными средствами OpenCV
    /*

    По умолчанию в opencv цветное изображение хранится в палитре BGR.
    Определять цвет в BGR не очень удобно, поэтому для начала переведем изображение в формат HSV.
    HSV (или HSB) означает Hue, Saturation, Value (Brightness), где:

     - Hue — цветовой тон, т.е. оттенок цвета.
     - Saturation — насыщенность. Чем выше этот параметр, тем «чище» будет цвет, а чем ниже, тем ближе он будет к серому.
     - Value (Brightness) — значение (яркость) цвета. Чем выше значение, тем ярче будет цвет (но не белее). А чем ниже, тем темнее (0% — черный)

    Так как искать растение мы будем именно по цвету, то больше всего нас интересует именно тон.
    Преобразуем изображение в палитру HSV и разобьем на три составляющие Hue Saturation Value соответственно.

    */


    // Переводим в формат HSV

    Mat hsv = Mat(src.cols, src.rows, 8, 3); //
    vector<Mat> splitedHsv = vector<Mat>();
    cvtColor(src, hsv, cv :: COLOR_BGR2HSV);
    split(hsv, splitedHsv);

    // Зададим диапазон значений тона. В OpenCV зеленый находится в диапазоне от 34 до 72.
    // Роза на фотографиях не зеленая. Поэтому опытным путем был подобран диапазон от 21 до 110.

    /*
    Далее пробежимся по нашему изображению.
    Для каждого пикселя получим все три компоненты.
    Интенсивность мы использовать не будем, но, чтобы было понятнее и не перескакивать индексы я ее оставлю.
    Если тон не укладывается в заданный диапазон или яркость слишком низкая – значит это фон,
    поэтому закрашиваем все белым цветом.
    */

    //Удаляем фон

    for (int y = 0; y < hsv.cols; y++) {
	for (int x = 0; x < hsv.rows; x++) {
		// получаем HSV-компоненты пикселя
		int H = static_cast<int>(splitedHsv[0].at<uchar>(x, y));        // Тон
		int S = static_cast<int>(splitedHsv[1].at<uchar>(x, y));        // Интенсивность
		int V = static_cast<int>(splitedHsv[2].at<uchar>(x, y));        // Яркость

		//Если яркость слишком низкая либо Тон не попадает у заданный диапазон, то закрашиваем белым
		if ((V < 13) || (H < GREEN_MIN) || (H > GREEN_MAX)) {
			src.at<Vec3b>(x, y)[0] = 255;
			src.at<Vec3b>(x, y)[1] = 255;
			src.at<Vec3b>(x, y)[2] = 255;
		}
	}
}

// В результате у нас получится такое изображение

    //imshow("src", src);




// В целом фон удалился, но остались непонятные шумы.
// Один из способов убрать мелкие несвязные частицы — это морфологическая обработка изображений

/*
Дилатация (морфологическое расширение) – свертка изображения или выделенной области изображения с некоторым ядром.
Ядро может иметь произвольную форму и размер.
При этом в ядре выделяется единственная ведущая позиция, которая совмещается с текущим пикселем
при вычислении свертки. Во многих случаях в качестве ядра выбирается квадрат или круг с ведущей позицией в центре.
Ядро можно рассматривать как шаблон или маску.
Применение дилатации сводится к проходу шаблоном по всему изображению и применению оператора поиска
локального максимума к интенсивностям пикселей изображения, которые накрываются шаблоном.
Такая операция вызывает рост светлых областей на изображении.
На рисунке серым цветом отмечены пиксели, которые в результате применения дилатации будут белыми.

Эрозия (морфологическое сужение) – обратная операция.
Действие эрозии подобно дилатации, разница лишь в том, что используется оператор поиска
локального минимума серым цветом залиты пиксели, которые станут черными в результате эрозии.
*/

// Применим морфологические операции к нашим картинкам.
// В качестве структурного элемента возьмем эллипс.

    //Морфологическое замыкание для удаления остаточных шумов
    Mat tmp;
    int an = 3;
    Mat element = getStructuringElement(MORPH_ELLIPSE, Size(an * 2 + 1, an * 2 + 1), Point(an, an));
    dilate(src, tmp, element);
    erode(tmp, tmp, element);

	// Переводим изображение в чернобелый формат
	Mat grayscaleMat;
	cvtColor(tmp, grayscaleMat, cv :: COLOR_BGR2GRAY);

	//Делаем бинарную маску
	Mat mask(grayscaleMat.size(), grayscaleMat.type());
	Mat out(src.size(), src.type());
	threshold(grayscaleMat, mask, 200, 255, THRESH_BINARY_INV);

	//Финальное изображение предварительно красим в белый цвет
	out = Scalar::all(255);
	//Копируем зашумленное изображение через маску
	src.copyTo(out, mask);

	 // imshow("До замыкания", src);
	 imshow("Результат", out);
	 // imshow("Результат замыкания", tmp);

waitKey(0);
return 0;
}
